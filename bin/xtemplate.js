#!/usr/bin/env node
//noinspection JSUnresolvedFunction,JSUnresolvedVariable
/**
 * Generate xtemplate function by xtemplate file using kissy xtemplate.
 * @author yiminghe@gmail.com
 */
var program = require('commander');
var esprima = require('esprima');
var escodegen = require('escodegen');
var encoding = 'utf-8';

var S = require('../lib/loader'),
    util = require('../lib/util'),
    XTemplateCompiler = require('../lib/xtemplate').Compiler,
    chokidar = require('chokidar'),
    fs = require('fs'),
    path = require('path');

var jshint = '/*jshint quotmark:false, loopfunc:true, ' +
    'indent:false, asi:true, unused:false, boss:true, sub:true*/\n';

var tplTemplate = '' +
    '/*\n' +
    '  Generated by kissy-tpl2mod.' +
    '*/\n' +
    jshint +
    'KISSY.add(function(){\n' +
    'return \'{code}\';\n' +
    '});';

function normalizeSlash(str) {
    return str.replace(/\\/g, '/');
}

function getFunctionName(path) {
    var name = path;
    if (name.indexOf('/') !== -1) {
        name = name.substring(name.lastIndexOf('/') + 1);
    }
    name = name.replace(/[-.]([a-z])/ig, function () {
        return arguments[1].toUpperCase();
    });
    name = name.replace(/\..+$/, '');
    return name;
}

function myJsBeautify(str) {
    try {
        return escodegen.generate(esprima.parse(str));
    } catch (e) {
        console.log('syntax error: ');
        console.log(str);
        throw e;
    }
}

function compile(tplFilePath, modulePath,wrap) {
    var moduleCode = getCompileModule(tplFilePath, tplFilePath,wrap);
    fs.writeFileSync(modulePath, moduleCode, encoding);
    console.info('generate xtpl module: ' + modulePath + ' at ' + (new Date().toLocaleString()));
}

function getCompileModule(tplFilePath, tplName, wrap) {
    var tplContent = fs.readFileSync(tplFilePath, encoding);
    var functionName = getFunctionName(tplName);
    return '/** Compiled By kissy-xtemplate */\n' +
        jshint +
        myJsBeautify((wrap ? 'KISSY.add(function(S,require,exports,module){\n' : '') +
            'var ' + functionName + ' = ' +
            XTemplateCompiler.compileToStr(tplContent, tplName, true) + ';\n' +
            functionName + '.TPL_NAME = module.name;\n' +
            functionName + '.version = "' + S.version + '";\n' +
            'module.exports = ' + functionName + ';\n' +
            (wrap ? '});' : ''));
}

if (require.main === module) {
    (function () {
        function generate(filePath) {
            var modulePath;
            if (suffix && util.endsWith(filePath, '.' + suffix)) {
                modulePath = filePath.replace(suffixReg, '.js');
                compile(filePath, modulePath,wrap);
            } else if (util.endsWith(filePath, '.xtpl.html') || util.endsWith(filePath, '-xtpl.html')) {
                modulePath = filePath.replace(/[.-]xtpl\.html$/, '-xtpl.js');
                compile(filePath, modulePath,wrap);
            } else if (util.endsWith(filePath, '.tpl.html')) {
                modulePath = filePath.replace(/\.tpl\.html$/, '-tpl.js');
                var tplContent = fs.readFileSync(filePath, encoding);
                tplContent = tplContent.replace(/\\/g, '\\')
                    .replace(/\r?\n/g, '\\n')
                    .replace(/'/g, '\\\'');
                var moduleCode = myJsBeautify(util.substitute(tplTemplate, {
                    code: tplContent
                }));
                fs.writeFileSync(modulePath, moduleCode, encoding);
                console.info('generate tpl module: ' + modulePath +
                    ' at ' + (new Date().toLocaleString()));
            }
        }

        program
            .option('-p, --packagePath <packagePath>', 'Set kissy package path')
            .option('-s, --suffix [suffix]', 'Set xtemplate file suffix', '')
            .option('-w, --watch', 'Watch xtemplate file change')
            .option('--no-wrap', 'Wrap code by KISSY module')
            .parse(process.argv);

        var options = program.options;

        options.forEach(function (o) {
            var name = o.name();
            if (o.required && !(name in program)) {
                program.optionMissingArgument(o);
            }
        });

        var packagePath = program.packagePath,
            suffix = program.suffix,
            wrap = program.wrap,
            cwd = process.cwd();

        var suffixReg;

        if (suffix) {
            suffixReg = new RegExp('\\.' + suffix + '$', 'g');
        }

        packagePath = path.resolve(cwd, packagePath);

        if (program.watch) {
            var watcher = chokidar.watch(packagePath, {ignored: /^\./, persistent: true});
            watcher.on('add', generate).on('change', generate);
        } else {
            var walk = require('walk');
            //noinspection JSUnresolvedFunction
            var walker = walk.walk(packagePath);
            walker.on('file', function (root, fileStats, next) {
                var filePath = normalizeSlash(root + '/' + fileStats.name);
                generate(filePath);
                next();
            });
        }
    })();
}

exports.getCompileModule = getCompileModule;